<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Fuyao-Jiang"><meta name="description" content="区块链开发、golang、智能合约、共识算法、密码学、Bitcoin、Ethereum、Bitshare源码解析、超级账本"><link rel="alternative" href="/atom.xml" title="姜富耀 | BlockChain" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>区块链开发 Solidity智能合约：变量、函数类型 - 姜富耀 | BlockChain</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0;"><header class="head"><h1 class="head-title u-fl"><a href="/">姜富耀 | BlockChain</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">☯ DIR'/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2018-02-06T11:22:50.000Z">二月 6, 2018</time><h1 class="post__title"><a href="/2018/02/06/区块链开发-Solidity智能合约：变量、函数类型/">区块链开发 Solidity智能合约：变量、函数类型</a></h1><div class="post__main echo"><h2 id="public、private、internal-在状态变量中的作用。"><a href="#public、private、internal-在状态变量中的作用。" class="headerlink" title="public、private、internal 在状态变量中的作用。"></a>public、private、internal 在状态变量中的作用。</h2><blockquote>
<p> <strong>internal</strong>类型的属性可以在合约自己内部和子类中使用<br>  <strong>private</strong>类型的属性只能在合约内部自己使用<br>  <strong>public</strong>类型的属性，除了能够在合约内部是子类中使用以外，<br>  还可以自动生成一个get行数，函数名和属性名相同，返回值为属性自己  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract Animal1 &#123;</span><br><span class="line"></span><br><span class="line">  uint age; //默认的就是internal</span><br><span class="line">  string private sex;// private</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Animal2 &#123;</span><br><span class="line">  uint public weight;// public</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> //Dog可以同时继承自多个父类，多继承</span><br><span class="line">contract Dog is Animal1 , Animal2 &#123;</span><br><span class="line">  function test() private &#123;</span><br><span class="line">    age = 100; // internal 成功继承</span><br><span class="line">    /* sex = &quot;male&quot;; private 无法继承，报错 */</span><br><span class="line">    weight = 130; //public成功继承</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 浏览器IDE 编译：<code>https://ethereum.github.io/browser-solidity/</code><br>复制到里面，<code>F5</code>刷新，选择<code>JavaScript VM</code>，编译<code>Dog</code>合约，看结果：  </p>
<p><img src="http://p37d7w3w4.bkt.clouddn.com/sol2-1.png" alt="solidity">  </p>
<blockquote>
<p>发现，<code>age = 100;</code> 没有报错，说明internal成功继承，但没有出现 <code>age</code>按钮，说明<code>internal</code> 只能合约内部调用和子类继承，外部不能使用。<br>出现<code>weight</code>按钮，说明<code>public</code>不光合约内部调用，子类继承，而且可以外部调用。  </p>
</blockquote>
<h2 id="函数的格式"><a href="#函数的格式" class="headerlink" title="函数的格式"></a>函数的格式</h2><blockquote>
<p>标准的函数格式：  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract Animal &#123;</span><br><span class="line"></span><br><span class="line">    function 函数名(参数) public|private|internal|external pure|constant|view 无返回值|returns (返回值类型)</span><br><span class="line">    </span><br><span class="line">    function getAge() public pure returns (uint) &#123;</span><br><span class="line">      return 30;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="view-和-pure-用法"><a href="#view-和-pure-用法" class="headerlink" title="view 和 pure 用法"></a>view 和 pure 用法</h2><blockquote>
<p><code>第一点</code>：只有有返回值的情况下，才会使用<strong>view</strong> 或 <strong>pure</strong><br>  <code>第二点</code>：<strong>pure</strong>，如果返回值返回的是一个<strong>纯粹的值</strong>，返回的不是变量，直接使用<strong>pure</strong><br>  <code>第三点</code>：如果返回的是<strong>全局变量或者是属性</strong>，使用<strong>view</strong>  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract Animal &#123;</span><br><span class="line"></span><br><span class="line">    string homeAddress = &quot;北京市昌平区300号楼&quot;;</span><br><span class="line">    uint weight; //体重</span><br><span class="line"></span><br><span class="line">    // pure</span><br><span class="line">    function getAge() public pure returns (uint) &#123;</span><br><span class="line">      return 30;</span><br><span class="line">    &#125;</span><br><span class="line">    // view</span><br><span class="line">    function getCurrentAdd() public view returns (address) &#123;</span><br><span class="line">      return msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    //view</span><br><span class="line">    function getHomeAddress() public view returns (string) &#123;</span><br><span class="line">      return homeAddress;</span><br><span class="line">    &#125;</span><br><span class="line">    //set方法，没有返回值，所以不需要 pure 或 view</span><br><span class="line">    function setWeight(uint w) public &#123;</span><br><span class="line">        weight = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getWeight()  public view  returns (uint) &#123;</span><br><span class="line">      return weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制代码到 在线浏览器IDE 中编译：  </p>
<p><img src="http://p37d7w3w4.bkt.clouddn.com/sol2-2.png" alt="solidity">  </p>
<h2 id="函数-的-public、private、internal和external"><a href="#函数-的-public、private、internal和external" class="headerlink" title="函数 的 public、private、internal和external"></a>函数 的 public、private、internal和external</h2><blockquote>
<p><strong>public</strong>：公有，子类能够继承，不管和子类还是自己，内部、外部均可访问<br> <strong>internal</strong>：内部，内部能够正常访问，子类能够正常继承，但是不能供外部访问<br> <strong>private</strong> ：私有，函数只能供合约内部自己访问，外部不能访问，子类不能继承<br> <strong>external</strong>：外部，子类能够继承，但是只能供外部访问  </p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract Animal &#123;</span><br><span class="line">  function testPublic() public pure returns (string) &#123;</span><br><span class="line">    return &quot;public&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function testInternal() internal pure returns (string) &#123;</span><br><span class="line">    return &quot;internal&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function testPrivate() private pure returns (string) &#123;</span><br><span class="line">    return &quot;private&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function testExternal() external pure returns (string) &#123;</span><br><span class="line">    return &quot;external&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function f() public &#123;</span><br><span class="line">    testPublic();</span><br><span class="line">    testInternal();</span><br><span class="line">    testPrivate();</span><br><span class="line">    /* testExternal(); //报错，因为只能供外部访问 */</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行，看结果，别忘点<code>JavaScript VM</code>，<code>Create</code>：<br><img src="http://p37d7w3w4.bkt.clouddn.com/sol2-3.png" alt="">  </p>
<h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><blockquote>
<p>子类重写了父类继承过来的方法，会以子类的方法为基准  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">// 只继承，并未 重写 案例</span><br><span class="line">contract Animal &#123;</span><br><span class="line">  function testFunc() public pure returns (string) &#123;</span><br><span class="line">    return &quot;Animal testFunc&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Dog is Animal &#123;  //Dog 子类继承 Animal父类</span><br><span class="line">  </span><br><span class="line">  //注意，本案例，先演示继承。并未重写。</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译，运行 <code>Dog</code>，看结果：  </p>
<p><img src="http://p37d7w3w4.bkt.clouddn.com/sol2-4.png" alt=""><br>成功 继承。  </p>
<blockquote>
<p>重写 案例：  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^ 0.4.19;</span><br><span class="line"></span><br><span class="line">contract Animal &#123;</span><br><span class="line">  function testFunc() public pure returns(string) &#123;</span><br><span class="line">    return &quot;Animal testFunc&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Dog is Animal &#123;</span><br><span class="line">  //继承，并 重写。</span><br><span class="line">  function testFunc() public pure returns(string) &#123;</span><br><span class="line">    return &quot;Dog testFunc&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译，运行 <code>Dog</code>，看结果：  </p>
<p><img src="http://p37d7w3w4.bkt.clouddn.com/sol2-5.png" alt="solidity">  </p>
<h2 id="值类型-和-引用类型"><a href="#值类型-和-引用类型" class="headerlink" title="值类型 和 引用类型"></a>值类型 和 引用类型</h2><blockquote>
<p><strong>值类型</strong>，可以理解为，深拷贝(拷贝了一份数据空间，改变数值不对影响被拷贝的原数值)<br><code>值类型</code>有：<br>布尔(Booleans)<br>整型(Integer)<br>地址(Address)<br>定长字节数组(fixed byte arrays)<br>有理数和整型(Rational and Integer Literals，String literals)<br>枚举类型(Enums)<br>函数(Function Types)  </p>
<p><strong>引用类型</strong>，可以有两种，浅拷贝、深拷拷贝<br>(浅拷贝：指针指向被拷贝数值，改变数值都会变)<br><code>引用类型</code>有：<br>不定长字节数组（bytes）<br>字符串（string）<br>数组（Array）<br>结构体（Struts）  </p>
</blockquote>
<h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><blockquote>
<p>下面这个值类型案例，大家来猜，调用<code>f</code>函数后，在调用<code>getA</code>，得到结果是多少？答对，公众号回复，有奖！1BTC  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^ 0.4.19;</span><br><span class="line"></span><br><span class="line">//值类型的使用相当于深拷贝</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">  uint a = 100;</span><br><span class="line"></span><br><span class="line">  function f() public&#123;</span><br><span class="line">    m(a); //把100传给临时的保险箱a</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function m(uint a) private &#123;</span><br><span class="line">    a = 1000;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getA() public view returns (uint) &#123;</span><br><span class="line">    return a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://p37d7w3w4.bkt.clouddn.com/sol2-6.png" alt=""></p>
<p>  值类型，深拷贝，改变数据元数据不会被改变。相当于复制了一份。  </p>
<blockquote>
<p>再来看 ，string类型 它属于 引用类型。下面案例，调用<code>f</code>函数，然后调用<code>getA</code>，得到什么结果？  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^ 0.4.19;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">  string a = &quot;100&quot;;</span><br><span class="line"></span><br><span class="line">  function f() public&#123;</span><br><span class="line">    m(a); //把100传给临时的保险箱a</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function m(string aa) private &#123;</span><br><span class="line">    aa = &quot;1000&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getA() public view returns (string) &#123;</span><br><span class="line">    return a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://p37d7w3w4.bkt.clouddn.com/sol2-7.png" alt="">  </p>
<blockquote>
<p>纳尼！？ 还是 100，不是说string 是引用类型吗？</p>
</blockquote>
<p>Yes，引用类型，深拷贝，浅拷贝 两种方式。  </p>
<blockquote>
<p>引用类型，有两个关键字： <strong>memory</strong> 和 <strong>storage</strong>  </p>
</blockquote>
<p>默认为 <strong>memory</strong>,深拷贝。<br><strong>storage</strong> 则为 浅拷贝。  </p>
<blockquote>
<ul>
<li><p>注意1： 如果一个函数的参数是<strong>storage</strong>类型，那么这个函数必须是<br><strong>internal</strong>或者是<strong>private</strong>类型，否则会报错！  </p>
</li>
<li><p>注意2：<strong>string</strong>不能够直接修改，需要转换为可变的字节数组才能够修改  </p>
</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^ 0.4.19;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">  string a = &quot;100&quot;;</span><br><span class="line"></span><br><span class="line">  function f() public&#123;</span><br><span class="line">    m(a); //把100传给临时的保险箱a</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function m(string storage aa) internal &#123;</span><br><span class="line">    //aa = &quot;1000&quot;; //报错，因为string不能够直接修改，需要转换为可变的字节数组才能够修改</span><br><span class="line">    bytes(aa)[0] = &apos;6&apos;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getA() public view returns (string) &#123;</span><br><span class="line">    return a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在浏览器编译器运行，运行 <code>getA</code> 发现结果为<code>100</code>，然后调用<code>f</code>函数，再运行<code>getA</code>结果变为<code>600</code>：  </p>
<p><img src="http://p37d7w3w4.bkt.clouddn.com/sol2-8.png" alt="solidity">  </p>
<hr>
<blockquote>
<p><strong><em>日后随着 学习打怪的不断深入，会解锁其他的高级教程。</em></strong>  </p>
<h3 id="期待-吗？-那就关注下面-公众号-随时锁定区块链开发学习教程进度-："><a href="#期待-吗？-那就关注下面-公众号-随时锁定区块链开发学习教程进度-：" class="headerlink" title="期待 吗？ 那就关注下面 公众号 随时锁定区块链开发学习教程进度 ：)"></a><strong><em>期待 吗？ 那就关注下面 公众号 随时锁定区块链开发学习教程进度 ：)</em></strong></h3></blockquote>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="/tags/Solidity/">Solidity</a></li></ul></footer></article><section class="reward"><a class="btn-reward" href="#">关注公众号</a><div class="reward-wrapper clearfix"><img src="/img/wechat.jpg" title="公众号：区块链开发技术共享"><img src="/img/lianhu.jpg" title="公众号：区块链部落"></div></section><div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC8zMzU4MC8xMDEzNQ=="><script>(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');</script></div></main><footer class="foot"><div class="foot-copy">&copy; 2018 Fuyao-Jiang</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>