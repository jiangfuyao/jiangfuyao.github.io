<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Fuyao-Jiang"><meta name="description" content="区块链开发、golang、智能合约、共识算法、密码学、Bitcoin、Ethereum、Bitshare源码解析、超级账本"><link rel="alternative" href="/atom.xml" title="姜富耀 | BlockChain" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>go语言 实现简单区块链(一) - 姜富耀 | BlockChain</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0;"><header class="head"><h1 class="head-title u-fl"><a href="/">姜富耀 | BlockChain</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">☯ DIR'/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2018-04-10T11:13:38.000Z">四月 10, 2018</time><h1 class="post__title"><a href="/2018/04/10/golang-实现简单区块链/">go语言 实现简单区块链(一)</a></h1><div class="post__main echo"><blockquote>
<p>简介</p>
</blockquote>
<p>本教程是从这篇优秀的文章改编的，关于使用Javascript编写基本区块链。我们已将它移植到Go并添加了一些额外的好东西，如在Web浏览器中查看您的区块链。<br>本教程中的数据示例将基于您的心跳。:-)为了好玩，在整个教程中记下你的脉搏一分钟（每分钟节拍）并记住这个数字。<br>世界上几乎每个开发商都听说过区块链，但大多数仍然不知道它是如何工作的。他们可能只知道比特币，因为他们听说过智能合约等事情。这篇文章试图通过帮助您在Go中编写自己的简单区块链，使用少于200行代码来揭开区块链的神秘面纱！到本教程结束时，您将能够在本地运行并写入区块链，并在Web浏览器中查看它。  </p>
<ul>
<li>了解区块链比创建自己的区块更好？  </li>
<li>你将能够做什么  </li>
<li>创建您自己的区块链  </li>
<li>了解哈希如何保持区块链的完整性  </li>
<li>了解如何添加新块  </li>
<li>看看当多个节点生成块时，tiebreakers如何解决  </li>
<li>在网页浏览器中查看您的区块链  </li>
<li>编写新的块  </li>
<li>获取区块链的基础知识，以便您可以决定您的知识旅行将带您从这里出发！  </li>
</ul>
<p>为了保持这篇文章的简单性，我们不会处理更高级的共识概念，例如工作证明与股权证明。网络交互将被模拟，以便您可以查看您的区块链并查看已添加的区块，但网络广播将留作未来的帖子。<br>让我们开始吧！  </p>
<blockquote>
<p>建立</p>
</blockquote>
<p>既然我们要用Go编写我们的代码，我们假设你已经有了Go的一些经验。在安装和配置Go之后，我们还需要获取以下软件包：  </p>
<p><code>$ go get github.com/davecgh/go-spew/spew</code><br><code>Spew</code>使我们能够在控制台中查看structs并slices清晰地格式化。这很好。  </p>
<p><code>$ go get github.com/gorilla/mux</code>  </p>
<p><code>Gorilla / mux</code>是编写Web处理程序的流行软件包。我们需要这个。</p>
<p><code>$ go get github.com/joho/godotenv</code>  </p>
<p><code>Gotdotenv</code>让我们从.env我们保存在我们目录根目录的文件中读取  数据，这样我们就不必像我们的http端口那样硬编码了。我们也需要这个。  </p>
<p>在的项目目录的根目录中创建一个<code>.env</code>文件，定义将提供http请求的端口。只需在该文件中添加一行：<br><code>ADDR=8080</code><br>创建一个<code>main.go</code>文件。从现在开始的所有内容都将写入此文件，并且少于200行代码。让我们来编码！</p>
<blockquote>
<p>import</p>
</blockquote>
<p>我们来写这些main.go，首先是import 和 声明：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"crypto/sha256"</span></span><br><span class="line">	<span class="string">"encoding/hex"</span></span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/davecgh/go-spew/spew"</span> <span class="comment">//在控制台中查看structs清晰地格式化</span></span><br><span class="line">	<span class="string">"github.com/gorilla/mux"</span>    <span class="comment">//编写Web处理程序包</span></span><br><span class="line">	<span class="string">"github.com/joho/godotenv"</span>  <span class="comment">//读取.env 端口</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>数据结构</p>
</blockquote>
<p>我们来定义struct组成区块链的每个区块。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">	Index     <span class="keyword">int</span>    <span class="comment">//区块号</span></span><br><span class="line">	Timestamp <span class="keyword">string</span> <span class="comment">//时间戳</span></span><br><span class="line">	BPM       <span class="keyword">int</span>    <span class="comment">//心率,演示写入区块链的数据</span></span><br><span class="line">	Hash      <span class="keyword">string</span>  <span class="comment">//是代表数据记录的SHA256标识符,哈希值</span></span><br><span class="line">	PrevHash  <span class="keyword">string</span> <span class="comment">//上一区块的哈希值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个Block数据都包含将写入区块链的数据，并将你的BPM心率写入区块中。  </p>
<p>我们还模拟出了blockchain本身，这是一个简单的slice的Block：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Blockchain []Block</span><br></pre></td></tr></table></figure>
<p>那么哈希如何适合区块和区块链呢？我们使用散列来确定并保持块的顺序。通过确保PrevHash每一个Block与Hash前一个相同，Block我们知道构成链的块的正确顺序。  </p>
<p><img src="http://p37d7w3w4.bkt.clouddn.com/goBC2.png" alt="">  </p>
<blockquote>
<p>哈希和生成新区块</p>
</blockquote>
<p>那么为什么我们需要散列哈希呢？我们散列数据有两个主要原因：<br>为了节省空间。哈希值来自块上的所有数据。在我们的例子中，我们只有一些数据点，但想象我们有来自数百，数千或数百万个先前块的数据。将这些数据散列到单个SHA256字符串或散列散列比将前面的块中的所有数据一遍又一遍地复制更为有效。<br>保持区块链的完整性。通过存储之前的哈希，就像我们在上图中所做的那样，我们能够确保区块链中的区块按照正确的顺序排列。如果一个恶意方进入并试图操纵这些数据（例如，为了改变我们的心率来修复人寿保险价格），哈希将会迅速改变，链条会“断裂”，并且每个人都会知道不信任那个恶意链。<br>我们来编写一个函数，它接收我们的Block数据并创建它的SHA256哈希值。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateHash</span><span class="params">(block Block)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	record := <span class="keyword">string</span>(block.Index) + block.Timestamp + <span class="keyword">string</span>(block.BPM) + block.PrevHash</span><br><span class="line">	h := sha256.New()</span><br><span class="line">	h.Write([]<span class="keyword">byte</span>(record))</span><br><span class="line">	hashed := h.Sum(<span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">return</span> hex.EncodeToString(hashed)</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">这个`</span>calculateHash<span class="string">`函数需要`</span>Index<span class="string">`，`</span>Timestamp<span class="string">`，`</span>BPM<span class="string">`，`</span>PrevHash<span class="string">`的Block数据我们提供作为参数，并返回`</span>SHA256哈希<span class="string">`为一个字符串。现在我们可以Block用一个新的`</span>generateBlock<span class="string">`函数生成一个新的元素，并带有我们需要的所有元素 我们需要为它提供前一个块，以便我们可以在BPM中获得散列和脉搏率。不要担心BPM int通过的参数，我们稍后会解决。  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateBlock</span><span class="params">(oldBlock Block, BPM <span class="keyword">int</span>)</span> <span class="params">(Block, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> newBlock Block</span><br><span class="line"></span><br><span class="line">	t := time.Now()</span><br><span class="line"></span><br><span class="line">	newBlock.Index = oldBlock.Index + <span class="number">1</span></span><br><span class="line">	newBlock.Timestamp = t.String()</span><br><span class="line">	newBlock.BPM = BPM</span><br><span class="line">	newBlock.PrevHash = oldBlock.Hash</span><br><span class="line">	newBlock.Hash = calculateHash(newBlock)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> newBlock, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，当前时间将自动写入块中<code>time.Now()</code>。另外请注意，我们之前的<code>calculateHash</code>函数被调用。<code>PrevHash</code>从前一个块的散列复制而来。<code>Index</code>从前一个块的索引增加。  </p>
<blockquote>
<p>区块的验证</p>
</blockquote>
<p>现在我们需要编写一些函数来确保块没有被篡改。我们通过检查Index来确保它们按预期递增。我们也检查以确保我们<code>PrevHash</code>的确与<code>Hash</code>前一个区块相同。最后，我们想通过在当前块上<code>calculateHash</code>再次运行该函数来检查当前块的散列。让我们写一个<code>isBlockValid</code>函数来完成所有这些事情并返回一个<code>bool</code>。true如果它通过我们所有的验证，它会返回：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isBlockValid</span><span class="params">(newBlock, oldBlock Block)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> oldBlock.Index+<span class="number">1</span> != newBlock.Index &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> oldBlock.Hash != newBlock.PrevHash &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> calculateHash(newBlock) != newBlock.Hash &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们遇到一个问题，即我们区块链生态系统的两个节点都在链中添加了块，并且我们都收到了这两个节点。我们选择哪一个作为真相的来源？我们选择最长的链。这是一个经典的区块链问题，与恶毒的捣鬼者无关。<br>两个含义很好的节点可能只有不同的链长，所以自然而然地，较长的节点将是最新的并具有最新的块。因此，让我们确保我们所采用的新链条比我们现有的链条更长。如果是这样，我们可以用新的块覆盖我们的链。   </p>
<p><img src="http://p37d7w3w4.bkt.clouddn.com/goBC3.png" alt="最长链"></p>
<p>我们只是比较链条切片的长度来实现这一点：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">replaceChain</span><span class="params">(newBlocks []Block)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(newBlocks) &gt; <span class="built_in">len</span>(Blockchain) &#123;</span><br><span class="line">		Blockchain = newBlocks</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你已经做到了这一步，请拍背！我们基本上已经用我们需要的所有各种功能写下了我们区块链的胆量。<br>现在我们想要一个方便的方式来查看我们的区块链并写入它，最好在网络浏览器中，以便我们可以向我们的哥们儿展示！</p>
<blockquote>
<p>网络</p>
</blockquote>
<p>我们假设您已经熟悉Web服务器的工作方式，并且有一些经验将它们连接到Go中。我们现在将引导您完成整个过程。<br>我们将使用您之前下载的<code>Gorilla / mux</code>软件包来为我们完成繁重的工作。<br>让run我们用稍后调用的函数创建我们的服务器。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	mux := makeMuxRouter()</span><br><span class="line">	httpAddr := os.Getenv(<span class="string">"ADDR"</span>)</span><br><span class="line">	log.Println(<span class="string">"Listening on "</span>, os.Getenv(<span class="string">"ADDR"</span>))</span><br><span class="line">	s := &amp;http.Server&#123;</span><br><span class="line">		Addr:           <span class="string">":"</span> + httpAddr,</span><br><span class="line">		Handler:        mux,</span><br><span class="line">		ReadTimeout:    <span class="number">10</span> * time.Second,</span><br><span class="line">		WriteTimeout:   <span class="number">10</span> * time.Second,</span><br><span class="line">		MaxHeaderBytes: <span class="number">1</span> &lt;&lt; <span class="number">20</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := s.ListenAndServe(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，我们选择的端口来自我们<code>.env</code>之前创建的  文件。我们给自己一个快速的控制台信息，<code>log.Println</code>让我们知道服务器已启动并正在运行。我们稍后配置服务器ListenAndServe。漂亮的标准去东西。<br>现在我们需要编写<code>makeMuxRouter</code>定义所有处理程序的函数。要在浏览器中查看和写入我们的区块链，我们只需要2条路线，我们会将它们保持简单。如果我们发送GET请求，localhost我们会查看我们的区块链。如果我们向POST它发送请求，我们可以写信给它。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeMuxRouter</span><span class="params">()</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">	muxRouter := mux.NewRouter()</span><br><span class="line">	muxRouter.HandleFunc(<span class="string">"/"</span>, handleGetBlockchain).Methods(<span class="string">"GET"</span>)</span><br><span class="line">	muxRouter.HandleFunc(<span class="string">"/"</span>, handleWriteBlock).Methods(<span class="string">"POST"</span>)</span><br><span class="line">	<span class="keyword">return</span> muxRouter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是我们的GET处理程序：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleGetBlockchain</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	bytes, err := json.MarshalIndent(Blockchain, <span class="string">""</span>, <span class="string">"  "</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	io.WriteString(w, <span class="keyword">string</span>(bytes))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们只是回写完整的<code>JSON格式</code>的区块链，我们可以通过访问浏览任何浏览器<code>localhost:8080</code>。我们ADDR在我们的<code>.env</code>文件中将变量设置为8080，所以如果您更改它，请确保访问您的正确端口。<br>我们的POST要求有点复杂，但不是太多。首先，我们需要一个新的Message struct。我们将在第二秒解释为什么我们需要它。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">	BPM <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是编写新块的处理程序的代码。阅读完之后，我们会带你通读它。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleWriteBlock</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m Message</span><br><span class="line"></span><br><span class="line">	decoder := json.NewDecoder(r.Body)</span><br><span class="line">	<span class="keyword">if</span> err := decoder.Decode(&amp;m); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		respondWithJSON(w, r, http.StatusBadRequest, r.Body)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> r.Body.Close()</span><br><span class="line"></span><br><span class="line">	newBlock, err := generateBlock(Blockchain[<span class="built_in">len</span>(Blockchain)<span class="number">-1</span>], m.BPM)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		respondWithJSON(w, r, http.StatusInternalServerError, m)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> isBlockValid(newBlock, Blockchain[<span class="built_in">len</span>(Blockchain)<span class="number">-1</span>]) &#123;</span><br><span class="line">		newBlockchain := <span class="built_in">append</span>(Blockchain, newBlock)</span><br><span class="line">		replaceChain(newBlockchain)</span><br><span class="line">		spew.Dump(Blockchain)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	respondWithJSON(w, r, http.StatusCreated, newBlock)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用一个单独的<code>Message结构</code>的原因是需要我们用来写入新块的JSON POST请求的请求主体。这使我们可以简单地发送一个POST请求到下面的主体，我们的处理程序会为我们填充剩下的块：<br><code>{&quot;BPM&quot;:50}</code><br>这50是一个以每分钟为单位的示例心率。通过将该整数更改为您自己的脉率来使用您自己的。<br>在完成将请求体解码到我们的<code>var m Message</code>结构之后，我们通过将前一个块和新的心率传入<code>generateBlock</code>我们之前编写的函数来创建一个新块。这是该功能创建新块所需的一切。我们做一个快速检查，确保使用<code>isBlockValid</code>我们之前创建的函数来确定新块是否为验证的区块。</p>
<p><code>spew.Dump</code>是一个方便的功能，可以将我们的结构打印到控制台中。这对调试很有用。<br>为了测试POST请求，我们喜欢使用Postman。curl如果你不能远离终端，那么它也可以工作得很好。<br>当我们的POST请求成功或失败时，我们希望相应地收到警报。我们使用一个小包装函数<code>respondWithJSON</code>让我们知道发生了什么。请记住，在Go中，不要忽略错误。优雅地处理它们。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">respondWithJSON</span><span class="params">(w http.ResponseWriter, r *http.Request, code <span class="keyword">int</span>, payload <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	response, err := json.MarshalIndent(payload, <span class="string">""</span>, <span class="string">"  "</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">		w.Write([]<span class="keyword">byte</span>(<span class="string">"HTTP 500: Internal Server Error"</span>))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	w.WriteHeader(code)</span><br><span class="line">	w.Write(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>几乎完成！ main</p>
</blockquote>
<p>让我们用一个简短的干净的<code>main函数</code>连接所有这些不同的区块链功能，Web处理程序和Web服务器：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := godotenv.Load()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		t := time.Now()</span><br><span class="line">		genesisBlock := Block&#123;<span class="number">0</span>, t.String(), <span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>&#125;</span><br><span class="line">		spew.Dump(genesisBlock)</span><br><span class="line">		Blockchain = <span class="built_in">append</span>(Blockchain, genesisBlock)</span><br><span class="line">	&#125;()</span><br><span class="line">	log.Fatal(run())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这里发生了什么？<br><code>godotenv.Load()</code>允许我们从<code>.env</code>我们放在目录根目录的文件中读取像我们的端口号这样的变量，所以我们不必在整个应用程序中对它们进行硬编码。<br><code>genesisBlock</code>是该功能中最重要的部分main。我们需要为我们的区块链提供一个初始块，否则一个新块将无法将其先前的散列与任何东西进行比较，因为之前的散列不存在。<br>我们将创世区块划分为自己的去程序，这样我们就可以从区块链逻辑和我们的网络服务器逻辑中分离出关注点。这可以在没有日常工作的情况下工作，但这种方式更简单。</p>
<blockquote>
<p>让我们试试看:-)</p>
</blockquote>
<p>从终端使用中启动程序<br> <code>go run main.go</code>  </p>
<p>在终端中，我们看到网络服务器已启动并正在运行，并且我们打印了我们的创始块。  </p>
<p><img src="http://p37d7w3w4.bkt.clouddn.com/goBC4.png" alt="创世"></p>
<p>现在，请访问<code>localhost</code>您的端口号，这对我们来说是<code>8080</code>.正如预期的那样，我们看到了相同的区块。  </p>
<p><img src="http://p37d7w3w4.bkt.clouddn.com/goBC5.png" alt="区块控制台"></p>
<p>现在，让我们发送一些<code>POST请求</code>来添加块。使用<code>Postman</code>(谷歌应用下载,图标是小飞人)，我们将添加一些新的块与各种BPM。  </p>
<p><img src="http://p37d7w3w4.bkt.clouddn.com/goBC6.png" alt="postman"></p>
<p>让我们刷新我们的浏览器。瞧，现在我们看到我们区块链里的所有新区块<code>PrevHash</code>我们的新区块相匹配<code>Hash</code>，就像我们预期的一样！</p>
<p><img src="http://p37d7w3w4.bkt.clouddn.com/goBC7.png" alt=""></p>
<blockquote>
<p>下一步</p>
</blockquote>
<p>！！您只需使用适当的散列和块验证来编写自己的区块链。您现在应该能够控制自己的区块链旅程，并探索更复杂的内容，如工作证明，股权证明，智能合约，Dapps，侧链等。<br>本教程未解决的是如何使用工作证明开采新区块。这将是一个单独的教程，但没有工作证明机制存在大量的区块链。此外，网络广播目前通过在网络服务器中编写和查看区块链来模拟。本教程中没有P2P组件。  </p>
<hr>
<blockquote>
<p><strong><em>日后随着 学习打怪的不断深入，会解锁其他的高级教程。</em></strong>  </p>
<h3 id="期待-吗？-那就关注下面-公众号-随时锁定区块链开发学习教程进度-："><a href="#期待-吗？-那就关注下面-公众号-随时锁定区块链开发学习教程进度-：" class="headerlink" title="期待 吗？ 那就关注下面 公众号 随时锁定区块链开发学习教程进度 ：)"></a><strong><em>期待 吗？ 那就关注下面 公众号 随时锁定区块链开发学习教程进度 ：)</em></strong></h3></blockquote>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="/tags/区块链/">区块链</a></li></ul></footer></article><section class="reward"><a class="btn-reward" href="#">关注公众号</a><div class="reward-wrapper clearfix"><img src="/img/wechat.jpg" title="公众号：区块链开发技术共享"><img src="/img/lianhu.jpg" title="公众号：区块链部落"></div></section><div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC8zMzU4MC8xMDEzNQ=="><script>(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');</script></div></main><footer class="foot"><div class="foot-copy">&copy; 2018 Fuyao-Jiang</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>